import time
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import xgboost  as xgb
import lightgbm
from sklearn.ensemble import RandomForestRegressor

data = pd.read_excel('database.xlsx')
X = data[['F','S','SH','SS','W','FA','CA','T','RH','Age']]
Y = data[['CS']]
Y = Y.values.reshape(295)

X_train, X_test_1, Y_train, Y_test_1 = train_test_split(X, Y,train_size=0.7, test_size=0.3)
X_test, X_validation, Y_test, Y_validation = train_test_split(X_test_1, Y_test_1,train_size=0.66, test_size=0.34)

Auto_ML = joblib.load('Auto_ML.pkl')

XGB_model = xgb.XGBRegressor(colsample_bytree=0.41414688678169476,learning_rate=0.2795914145693104,max_depth=2,n_estimators=260).fit(X_train,Y_train)

LGB_model = lightgbm.LGBMRegressor(bagging_fraction=0.7126028415107389, feature_fraction=0.7273928858281407,learning_rate=0.3225037772156626,max_depth=13,num_leaves=290).fit(X_train,Y_train)

RF_model = RandomForestRegressor(max_depth=5, max_features= 7,n_estimators=115).fit(X_train,Y_train)

class Particle:
    def __init__(self, dim, lb, ub):
        self.position = np.random.uniform(lb, ub, dim)
        self.velocity = np.zeros(dim)
        self.best_position = self.position.copy()
        self.best_fitness = objective_function(self.position)
        self.rank = None
        self.distance = 0.0

def simple_non_dominated_sort(population):
    fronts = [[]]
    
    for p in population:
        p.dominated_set = []
        p.domination_count = 0

    for i, p in enumerate(population):
        for j, q in enumerate(population):
            if i == j:
                continue
            p_fitness = p.best_fitness.astype(np.float64)
            q_fitness = q.best_fitness.astype(np.float64)
            
            if np.all(p_fitness <= q_fitness) and np.any(p_fitness < q_fitness):
                p.dominated_set.append(q)
            elif np.all(p_fitness >= q_fitness) and np.any(p_fitness > q_fitness):
                p.domination_count += 1

        if p.domination_count == 0:
            p.rank = 0
            fronts[0].append(p)

    current_front = 0
    while fronts[current_front]:
        next_front = []
        for p in fronts[current_front]:
            for q in p.dominated_set:
                q.domination_count -= 1
                if q.domination_count == 0:
                    q.rank = current_front + 1
                    next_front.append(q)
        current_front += 1
        if next_front:
            fronts.append(next_front)
        else:
            break

    return fronts

def simple_crowding_distance(front):
    if not front:
        return

    fitness = np.array([p.best_fitness.astype(np.float64) for p in front])
    
    f_min = np.min(fitness, axis=0)
    f_max = np.max(fitness, axis=0)
    if np.all(f_min == f_max):
        for p in front:
            p.distance = 1.0
        return

    norm_fitness = (fitness - f_min) / (f_max - f_min + 1e-10)
    
    for p in front:
        p.distance = 0.0

    for m in range(fitness.shape[1]):
        indices = np.argsort(fitness[:, m])
        sorted_front = [front[i] for i in indices]

        sorted_front[0].distance = float('inf')
        sorted_front[-1].distance = float('inf')

        for i in range(1, len(sorted_front)-1):
            prev = norm_fitness[indices[i-1], m]
            next_ = norm_fitness[indices[i+1], m]
            sorted_front[i].distance += (next_ - prev)

def mopso(num_particles, num_iter, dim, lb, ub):
    assert len(lb) == dim and len(ub) == dim, 
    
    w_min, w_max = 0.4, 0.9
    c1, c2 = 1.5, 1.5
    
    swarm = [Particle(dim, lb, ub) for _ in range(num_particles)]
    archive = []
    
    for gen in range(num_iter):
        w = w_max - (w_max - w_min) * gen / num_iter
        
        candidates = []
        for p in swarm:
            candidates.append((p.best_position, p.best_fitness))
        for a in archive:
            candidates.append((a, objective_function(a)))
        
        fitness_values = [cf[1] for cf in candidates]
        nondominated = []
        for i, (pos, fit) in enumerate(candidates):
            dominated = False
            for j, (_, other_fit) in enumerate(candidates):
                if i == j:
                    continue
                if np.all(fit >= other_fit) and np.any(fit > other_fit):
                    dominated = True
                    break
            if not dominated:
                nondominated.append(pos)
        
        if len(nondominated) > num_particles:
            temp_pop = [Particle(dim, lb, ub) for _ in range(len(nondominated))]
            for i, p in enumerate(temp_pop):
                p.best_position = nondominated[i]
                p.best_fitness = objective_function(nondominated[i])
            fronts = simple_non_dominated_sort(temp_pop)
            selected = []
            for front in fronts:
                if len(selected) + len(front) <= num_particles:
                    selected.extend(front)
                else:
                    simple_crowding_distance(front)
                    front.sort(key=lambda x: x.distance, reverse=True)
                    selected.extend(front[:num_particles - len(selected)])
                    break
            archive = [p.best_position for p in selected]
        else:
            archive = nondominated[:num_particles]
        if archive:
            leader = archive[np.random.choice(len(archive))]
        else:
            leader = swarm[np.argmin([p.best_fitness[0] for p in swarm])].best_position
        
        for p in swarm:
            r1 = np.random.rand(dim)
            r2 = np.random.rand(dim)
            cognitive = c1 * r1 * (p.best_position - p.position)
            social = c2 * r2 * (leader - p.position)
            p.velocity = w * p.velocity + cognitive + social
          
            new_position = np.clip(p.position + p.velocity, lb, ub)
            
            new_fitness = objective_function(new_position)
            if (new_fitness.astype(np.float64) <= p.best_fitness.astype(np.float64)).all():
                p.position = new_position
                p.best_position = new_position.copy()
                p.best_fitness = new_fitness
    
    final_fitness = [objective_function(x) for x in archive]
    return swarm, np.array(final_fitness)

# run the althrithm
num_particles =   # number of paritcles
num_generations =  # max iteration
dimensions =  # the dim of the problem
lb = np.array([]) # lowerBound
ub = np.array([]) # upperBound

solution, non_dominated_solutions = mopso(num_particles, num_generations, dimensions, lb, ub)
